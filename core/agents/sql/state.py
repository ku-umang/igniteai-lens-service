"""LangGraph state schema for MAC-SQL workflow.

This module defines the state schema used by the MAC-SQL agent workflow.
The state tracks the entire journey from user question to executable SQL.
"""

import operator
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from core.integrations.schema import DataSourceResponse


class SchemaContext(BaseModel):
    """Schema context selected by the Selector agent."""

    tables: List[Dict[str, Any]] = Field(default_factory=list, description="Selected table metadata")
    columns: List[Dict[str, Any]] = Field(default_factory=list, description="Selected column metadata")
    relationships: List[Dict[str, Any]] = Field(default_factory=list, description="Table relationships (FKs)")
    example_queries: List[Dict[str, Any]] = Field(default_factory=list, description="Relevant example queries")
    reasoning: str = Field(default="", description="Selector agent reasoning")


class QueryPlan(BaseModel):
    """Query plan generated by the Decomposer agent."""

    steps: List[str] = Field(default_factory=list, description="Logical query steps")
    join_strategy: Optional[str] = Field(default=None, description="JOIN strategy (if applicable)")
    aggregations: List[str] = Field(default_factory=list, description="Aggregation operations needed")
    filters: List[str] = Field(default_factory=list, description="Filter conditions")
    complexity_score: float = Field(default=0.0, description="Query complexity score (0-1)")
    reasoning: str = Field(default="", description="Decomposer agent reasoning")


class GeneratedSQL(BaseModel):
    """SQL generated by the Refiner agent."""

    sql: str = Field(default="", description="Generated SQL query")
    dialect: str = Field(default="postgres", description="SQL dialect")
    is_valid: bool = Field(default=False, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors (if any)")
    estimated_complexity: int = Field(default=0, description="Estimated query complexity")
    reasoning: str = Field(default="", description="Refiner agent reasoning")


class ExecutionResult(BaseModel):
    """SQL execution result."""

    success: bool = Field(default=False, description="Execution success status")
    rows: List[Dict[str, Any]] = Field(default_factory=list, description="Rows returned")
    execution_time_ms: float = Field(default=0.0, description="Execution time in milliseconds")
    error_message: Optional[str] = Field(default=None, description="Error message (if failed)")
    cached: bool = Field(default=False, description="Result from cache")
    truncated: bool = Field(default=False, description="Whether the result was truncated")
    rows_returned: int = Field(default=0, description="Number of rows returned")


class VisualizationSpec(BaseModel):
    """Visualization specification for Plotly charts."""

    chart_type: str = Field(..., description="Type of chart (line, bar, scatter, etc.)")
    plotly_spec: Dict[str, Any] = Field(..., description="Plotly JSON specification")
    title: str = Field(..., description="Chart title")
    description: Optional[str] = Field(default=None, description="Chart description")
    generation_method: str = Field(default="rule_based", description="Generation method (rule_based or llm)")
    generation_time_ms: float = Field(default=0.0, description="Time taken to generate visualization")


class ChatMessage(BaseModel):
    """Simplified chat message for conversation history."""

    question: str = Field(..., description="User's question")
    sql: Optional[str] = Field(default=None, description="Generated SQL (if any)")


class MACSSQLState(BaseModel):
    """State schema for MAC-SQL workflow using LangGraph.

    This state is passed between agents and tracks the complete workflow
    from question to SQL execution.
    """

    # Input
    user_question: str = Field(..., description="User's natural language question")
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    datasource: DataSourceResponse = Field(..., description="Datasource")
    session_id: Optional[str] = Field(default=None, description="Session ID for context/history")

    # Chat History & Optimization
    chat_history: List[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation history for context-aware optimization",
    )
    original_question: Optional[str] = Field(default=None, description="User's original raw question")
    optimized_question: Optional[str] = Field(
        default=None,
        description="Context-aware optimized question (after optimizer agent)",
    )
    optimization_metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Metadata from question optimization (changes made, reasoning)",
    )

    # Schema Selection (Selector Agent)
    schema_context: Optional[SchemaContext] = Field(default=None, description="Selected schema context")

    # Query Planning (Decomposer Agent)
    query_plan: Optional[QueryPlan] = Field(default=None, description="Logical query plan")

    # SQL Generation (Refiner Agent)
    generated_sql: Optional[GeneratedSQL] = Field(default=None, description="Generated SQL")

    # Execution
    execution_result: Optional[ExecutionResult] = Field(default=None, description="Execution result")

    # Visualization
    visualization_spec: Optional[VisualizationSpec] = Field(default=None, description="Visualization specification")

    # Control Flow
    current_step: str = Field(default="selector", description="Current workflow step")
    iteration_count: int = Field(default=0, description="Number of iterations (for retries)")
    max_iterations: int = Field(default=3, description="Maximum allowed iterations")

    # Error Tracking
    errors: Annotated[List[str], operator.add] = Field(default_factory=list, description="Accumulated errors during workflow")

    # Metadata
    retrieval_time_ms: float = Field(default=0.0, description="Schema retrieval time")
    total_time_ms: float = Field(default=0.0, description="Total workflow time")
    llm_calls: int = Field(default=0, description="Number of LLM calls made")

    # Configuration
    explain_mode: bool = Field(default=False, description="If True, don't execute SQL, just generate")
    use_cache: bool = Field(default=True, description="Whether to use caching")
    timeout_seconds: float = Field(default=30.0, description="Query execution timeout")
    max_rows: int = Field(default=10000, description="Maximum rows to return")
    dialect: str = Field(default="postgres", description="SQL dialect from datasource (postgres, mysql, sqlite)")

    model_config = ConfigDict(arbitrary_types_allowed=True)


class MACSSQLInput(BaseModel):
    """Input schema for MAC-SQL workflow."""

    question: str = Field(..., description="Natural language question", min_length=1)
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    session_id: Optional[str] = Field(default=None, description="Session ID for context")
    chat_history: List[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation history for context-aware optimization",
    )
    explain_mode: bool = Field(default=False, description="Return reasoning without executing")
    use_cache: bool = Field(default=True, description="Use cached results if available")
    timeout_seconds: float = Field(default=30.0, description="Query execution timeout", gt=0, le=300)
    max_rows: int = Field(default=10000, description="Maximum rows to return", gt=0, le=100000)


class MACSSQLOutput(BaseModel):
    """Output schema for MAC-SQL workflow."""

    # Generated SQL
    sql: str = Field(..., description="Generated SQL query")
    dialect: str = Field(default="postgres", description="SQL dialect")

    # Results (if executed)
    data: Optional[List[Dict[str, Any]]] = Field(default=None, description="Query results (if executed)")
    rows_returned: int = Field(default=0, description="Number of rows returned")

    # Visualization
    visualization_spec: Optional[Dict[str, Any]] = Field(default=None, description="Chart visualization specification")

    # Reasoning (if explain_mode=True)
    schema_selection_reasoning: Optional[str] = Field(default=None, description="Selector agent reasoning")
    decomposition_reasoning: Optional[str] = Field(default=None, description="Decomposer agent reasoning")
    refinement_reasoning: Optional[str] = Field(default=None, description="Refiner agent reasoning")

    # Metadata
    execution_time_ms: float = Field(default=0.0, description="Total execution time")
    cached: bool = Field(default=False, description="Result from cache")
    complexity_score: float = Field(default=0.0, description="Query complexity score")

    # Validation
    is_valid: bool = Field(default=True, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors")

    # Error handling
    success: bool = Field(default=True, description="Overall success status")
    error_message: Optional[str] = Field(default=None, description="Error message if failed")
