import operator
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from core.integrations.schema import DataSourceResponse


class QuestionType(str, Enum):
    """Classification types for user questions."""

    WHAT_IF = "what_if"  # Scenario analysis, "what if X changes?"
    TREND = "trend"  # Time-based patterns
    CORRELATION = "correlation"  # Relationships between variables
    FORECASTING = "forecasting"  # Predict future values
    COMPARISON = "comparison"  # Compare groups/segments
    SEGMENTATION = "segmentation"  # Group similar items
    ANOMALY_DETECTION = "anomaly_detection"  # Find outliers
    DESCRIPTIVE = "descriptive"  # Basic statistics/summary


class QueryStepStatus(str, Enum):
    """Status of a query step in the execution plan."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class SchemaContext(BaseModel):
    """Schema context selected by the Selector agent."""

    tables: List[Dict[str, Any]] = Field(default_factory=list, description="Selected table metadata")
    columns: List[Dict[str, Any]] = Field(default_factory=list, description="Selected column metadata")
    relationships: List[Dict[str, Any]] = Field(default_factory=list, description="Table relationships (FKs)")
    example_queries: List[Dict[str, Any]] = Field(default_factory=list, description="Relevant example queries")
    reasoning: str = Field(default="", description="Selector agent reasoning")


class QueryPlan(BaseModel):
    """Query plan generated by the Decomposer agent."""

    steps: List[str] = Field(default_factory=list, description="Logical query steps")
    join_strategy: Optional[str] = Field(default=None, description="JOIN strategy (if applicable)")
    aggregations: List[str] = Field(default_factory=list, description="Aggregation operations needed")
    filters: List[str] = Field(default_factory=list, description="Filter conditions")
    complexity_score: float = Field(default=0.0, description="Query complexity score (0-1)")
    reasoning: str = Field(default="", description="Decomposer agent reasoning")


class GeneratedSQL(BaseModel):
    """SQL generated by the Refiner agent."""

    sql: str = Field(default="", description="Generated SQL query")
    dialect: str = Field(default="postgres", description="SQL dialect")
    is_valid: bool = Field(default=False, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors (if any)")
    estimated_complexity: int = Field(default=0, description="Estimated query complexity")
    reasoning: str = Field(default="", description="Refiner agent reasoning")


class ExecutionResult(BaseModel):
    """SQL execution result."""

    success: bool = Field(default=False, description="Execution success status")
    rows: List[Dict[str, Any]] = Field(default_factory=list, description="Rows returned")
    execution_time_ms: float = Field(default=0.0, description="Execution time in milliseconds")
    error_message: Optional[str] = Field(default=None, description="Error message (if failed)")
    cached: bool = Field(default=False, description="Result from cache")
    truncated: bool = Field(default=False, description="Whether the result was truncated")
    rows_returned: int = Field(default=0, description="Number of rows returned")


class VisualizationSpec(BaseModel):
    """Visualization specification for Plotly charts."""

    chart_type: str = Field(..., description="Type of chart (line, bar, scatter, etc.)")
    plotly_spec: Dict[str, Any] = Field(..., description="Plotly JSON specification")
    title: str = Field(..., description="Chart title")
    description: Optional[str] = Field(default=None, description="Chart description")
    generation_method: str = Field(default="rule_based", description="Generation method (rule_based or llm)")
    generation_time_ms: float = Field(default=0.0, description="Time taken to generate visualization")


class ClassificationResult(BaseModel):
    """Question classification result from Classifier agent."""

    question_type: QuestionType = Field(..., description="Classified question type")
    confidence: float = Field(..., description="Classification confidence score (0-1)", ge=0.0, le=1.0)
    reasoning: str = Field(default="", description="Classification reasoning")
    characteristics: List[str] = Field(default_factory=list, description="Key characteristics identified")


class QueryStep(BaseModel):
    """Individual query step in an execution plan."""

    step_number: int = Field(..., description="Step number in the plan (1-indexed)")
    description: str = Field(..., description="Natural language description of this step")
    purpose: str = Field(..., description="Why this step is needed")
    depends_on: List[int] = Field(default_factory=list, description="Step numbers this depends on")
    status: QueryStepStatus = Field(default=QueryStepStatus.PENDING, description="Current status")

    # SQL-specific requirements
    required_tables: List[str] = Field(default_factory=list, description="Tables needed for this step")
    aggregations: List[str] = Field(default_factory=list, description="Aggregations needed")
    filters: List[str] = Field(default_factory=list, description="Filter conditions")

    # Execution results (populated after execution)
    generated_sql: Optional[GeneratedSQL] = Field(default=None, description="Generated SQL for this step")
    execution_result: Optional[ExecutionResult] = Field(default=None, description="Execution result")
    schema_context: Optional[SchemaContext] = Field(default=None, description="Schema context for this step")


class ExecutionPlan(BaseModel):
    """Multi-step execution plan from Planner agent."""

    steps: List[QueryStep] = Field(default_factory=list, description="Ordered list of query steps")
    current_step_index: int = Field(default=0, description="Index of current step being executed (0-indexed)")
    is_complete: bool = Field(default=False, description="Whether all steps are completed")
    requires_iteration: bool = Field(default=False, description="Whether more steps may be added based on results")
    reasoning: str = Field(default="", description="Overall planning reasoning")
    strategy: str = Field(default="", description="High-level strategy for answering the question")


class AnalysisResult(BaseModel):
    """Analysis result synthesizing multiple query results."""

    insights: List[str] = Field(default_factory=list, description="Key insights from the analysis")
    answer: str = Field(..., description="Natural language answer to the original question")
    supporting_evidence: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Supporting data points and evidence",
    )
    confidence: float = Field(default=1.0, description="Confidence in the analysis (0-1)", ge=0.0, le=1.0)
    recommendations: List[str] = Field(default_factory=list, description="Actionable recommendations (if applicable)")
    limitations: List[str] = Field(default_factory=list, description="Known limitations or caveats")
    reasoning: str = Field(default="", description="Analysis reasoning")


class ChatMessage(BaseModel):
    """Simplified chat message for conversation history."""

    question: str = Field(..., description="User's question")
    sql: Optional[str] = Field(default=None, description="Generated SQL (if any)")


class AgentState(BaseModel):
    """State schema for Agent workflow using LangGraph.

    This state is passed between agents and tracks the complete workflow
    from question to SQL execution.
    """

    # Input
    user_question: str = Field(..., description="User's natural language question")
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    datasource: DataSourceResponse = Field(..., description="Datasource")
    session_id: Optional[str] = Field(default=None, description="Session ID for context/history")

    # Chat History & Optimization
    chat_history: List[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation history for context-aware optimization",
    )

    optimized_question: Optional[str] = Field(
        default=None,
        description="Context-aware optimized question (after optimizer agent)",
    )
    optimization_metadata: Optional[Dict[str, Any]] = Field(
        default=None,
        description="Metadata from question optimization (changes made, reasoning)",
    )

    # Question Classification (Classifier Agent)
    classification: Optional[ClassificationResult] = Field(default=None, description="Question classification result")

    # Schema Selection (Selector Agent) - may be populated multiple times for multi-query plans
    schema_context: Optional[SchemaContext] = Field(default=None, description="Selected schema context")

    # Query Planning (Planner Agent - replaces Decomposer)
    execution_plan: Optional[ExecutionPlan] = Field(default=None, description="Multi-step execution plan")
    query_plan: Optional[QueryPlan] = Field(
        default=None,
        description="[DEPRECATED] Legacy single query plan - kept for compatibility",
    )

    # SQL Generation (Refiner Agent)
    generated_sql: Optional[GeneratedSQL] = Field(default=None, description="Generated SQL for current step")

    # Execution - supports both single and multi-query workflows
    execution_result: Optional[ExecutionResult] = Field(
        default=None,
        description="Execution result for current step (or single query in legacy mode)",
    )
    query_results: List[ExecutionResult] = Field(
        default_factory=list,
        description="All execution results for multi-query plans",
    )

    # Analysis (Analysis Agent)
    analysis_result: Optional[AnalysisResult] = Field(
        default=None,
        description="Synthesized analysis of multiple query results",
    )

    # Visualization
    visualization_spec: Optional[VisualizationSpec] = Field(default=None, description="Visualization specification")

    # Control Flow
    current_step: str = Field(default="selector", description="Current workflow step")
    iteration_count: int = Field(default=0, description="Number of iterations (for retries)")
    max_iterations: int = Field(default=3, description="Maximum allowed iterations")

    # Error Tracking
    errors: Annotated[List[str], operator.add] = Field(default_factory=list, description="Accumulated errors during workflow")

    # Metadata
    retrieval_time_ms: float = Field(default=0.0, description="Schema retrieval time")
    total_time_ms: float = Field(default=0.0, description="Total workflow time")
    llm_calls: int = Field(default=0, description="Number of LLM calls made")

    # Configuration
    explain_mode: bool = Field(default=False, description="If True, don't execute SQL, just generate")
    use_cache: bool = Field(default=True, description="Whether to use caching")
    timeout_seconds: float = Field(default=30.0, description="Query execution timeout")
    max_rows: int = Field(default=5000, description="Maximum rows to return")
    dialect: str = Field(default="postgres", description="SQL dialect from datasource (postgres, mysql, sqlite)")

    model_config = ConfigDict(arbitrary_types_allowed=True)


class AgentInput(BaseModel):
    """Input schema for Agent workflow."""

    question: str = Field(..., description="Natural language question", min_length=1)
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    session_id: Optional[str] = Field(default=None, description="Session ID for context")
    chat_history: List[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation history for context-aware optimization",
    )
    explain_mode: bool = Field(default=False, description="Return reasoning without executing")
    use_cache: bool = Field(default=True, description="Use cached results if available")
    timeout_seconds: float = Field(default=30.0, description="Query execution timeout", gt=0, le=300)
    max_rows: int = Field(default=10000, description="Maximum rows to return", gt=0, le=100000)


class AgentOutput(BaseModel):
    """Output schema for Agent workflow."""

    # Classification
    question_type: Optional[str] = Field(default=None, description="Classified question type")
    classification_confidence: Optional[float] = Field(default=None, description="Classification confidence score")

    # Generated SQL (may be multiple for multi-query plans)
    sql: str = Field(..., description="Generated SQL query (primary or last query)")
    all_queries: Optional[List[str]] = Field(default=None, description="All SQL queries executed (for multi-query plans)")
    dialect: str = Field(default="postgres", description="SQL dialect")

    # Results (if executed)
    data: Optional[List[Dict[str, Any]]] = Field(default=None, description="Query results (if executed)")
    rows_returned: int = Field(default=0, description="Number of rows returned")
    all_results: Optional[List[Dict[str, Any]]] = Field(
        default=None,
        description="All query results for multi-query plans",
    )

    # Analysis (for multi-query workflows)
    analysis: Optional[Dict[str, Any]] = Field(default=None, description="Synthesized analysis result")
    insights: Optional[List[str]] = Field(default=None, description="Key insights from analysis")
    answer: Optional[str] = Field(default=None, description="Natural language answer to the question")

    # Visualization
    visualization_spec: Optional[Dict[str, Any]] = Field(default=None, description="Chart visualization specification")

    # Reasoning (if explain_mode=True)
    classification_reasoning: Optional[str] = Field(default=None, description="Classifier agent reasoning")
    schema_selection_reasoning: Optional[str] = Field(default=None, description="Selector agent reasoning")
    planning_reasoning: Optional[str] = Field(default=None, description="Planner agent reasoning")
    decomposition_reasoning: Optional[str] = Field(
        default=None,
        description="[DEPRECATED] Decomposer agent reasoning - use planning_reasoning",
    )
    refinement_reasoning: Optional[str] = Field(default=None, description="Refiner agent reasoning")
    analysis_reasoning: Optional[str] = Field(default=None, description="Analysis agent reasoning")

    # Metadata
    execution_time_ms: float = Field(default=0.0, description="Total execution time")
    cached: bool = Field(default=False, description="Result from cache")
    complexity_score: float = Field(default=0.0, description="Query complexity score")
    num_queries_executed: int = Field(default=1, description="Number of queries executed")

    # Validation
    is_valid: bool = Field(default=True, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors")

    # Error handling
    success: bool = Field(default=True, description="Overall success status")
    error_message: Optional[str] = Field(default=None, description="Error message if failed")
