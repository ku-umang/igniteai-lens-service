"""LangGraph state schema for MAC-SQL workflow.

This module defines the state schema used by the MAC-SQL agent workflow.
The state tracks the entire journey from user question to executable SQL.
"""

import operator
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from core.integrations.schema import DataSourceResponse


class SchemaContext(BaseModel):
    """Schema context selected by the Selector agent."""

    tables: List[Dict[str, Any]] = Field(default_factory=list, description="Selected table metadata")
    columns: List[Dict[str, Any]] = Field(default_factory=list, description="Selected column metadata")
    relationships: List[Dict[str, Any]] = Field(default_factory=list, description="Table relationships (FKs)")
    example_queries: List[Dict[str, Any]] = Field(default_factory=list, description="Relevant example queries")
    reasoning: str = Field(default="", description="Selector agent reasoning")


class QueryPlan(BaseModel):
    """Query plan generated by the Decomposer agent."""

    steps: List[str] = Field(default_factory=list, description="Logical query steps")
    join_strategy: Optional[str] = Field(default=None, description="JOIN strategy (if applicable)")
    aggregations: List[str] = Field(default_factory=list, description="Aggregation operations needed")
    filters: List[str] = Field(default_factory=list, description="Filter conditions")
    complexity_score: float = Field(default=0.0, description="Query complexity score (0-1)")
    reasoning: str = Field(default="", description="Decomposer agent reasoning")


class GeneratedSQL(BaseModel):
    """SQL generated by the Refiner agent."""

    sql: str = Field(default="", description="Generated SQL query")
    dialect: str = Field(default="postgres", description="SQL dialect")
    is_valid: bool = Field(default=False, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors (if any)")
    estimated_complexity: int = Field(default=0, description="Estimated query complexity")
    reasoning: str = Field(default="", description="Refiner agent reasoning")


class ExecutionResult(BaseModel):
    """SQL execution result."""

    success: bool = Field(default=False, description="Execution success status")
    rows: List[Dict[str, Any]] = Field(default_factory=list, description="Rows returned")
    execution_time_ms: float = Field(default=0.0, description="Execution time in milliseconds")
    error_message: Optional[str] = Field(default=None, description="Error message (if failed)")
    cached: bool = Field(default=False, description="Result from cache")
    truncated: bool = Field(default=False, description="Whether the result was truncated")
    rows_returned: int = Field(default=0, description="Number of rows returned")


class MACSSQLState(BaseModel):
    """State schema for MAC-SQL workflow using LangGraph.

    This state is passed between agents and tracks the complete workflow
    from question to SQL execution.
    """

    # Input
    user_question: str = Field(..., description="User's natural language question")
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    datasource: DataSourceResponse = Field(..., description="Datasource")
    session_id: Optional[str] = Field(default=None, description="Session ID for context/history")

    # Schema Selection (Selector Agent)
    schema_context: Optional[SchemaContext] = Field(default=None, description="Selected schema context")

    # Query Planning (Decomposer Agent)
    query_plan: Optional[QueryPlan] = Field(default=None, description="Logical query plan")

    # SQL Generation (Refiner Agent)
    generated_sql: Optional[GeneratedSQL] = Field(default=None, description="Generated SQL")

    # Execution
    execution_result: Optional[ExecutionResult] = Field(default=None, description="Execution result")

    # Control Flow
    current_step: str = Field(default="selector", description="Current workflow step")
    iteration_count: int = Field(default=0, description="Number of iterations (for retries)")
    max_iterations: int = Field(default=3, description="Maximum allowed iterations")

    # Error Tracking
    errors: Annotated[List[str], operator.add] = Field(default_factory=list, description="Accumulated errors during workflow")

    # Metadata
    retrieval_time_ms: float = Field(default=0.0, description="Schema retrieval time")
    total_time_ms: float = Field(default=0.0, description="Total workflow time")
    llm_calls: int = Field(default=0, description="Number of LLM calls made")

    # Configuration
    explain_mode: bool = Field(default=False, description="If True, don't execute SQL, just generate")
    use_cache: bool = Field(default=True, description="Whether to use caching")
    timeout_seconds: float = Field(default=30.0, description="Query execution timeout")
    max_rows: int = Field(default=10000, description="Maximum rows to return")
    dialect: str = Field(default="postgres", description="SQL dialect from datasource (postgres, mysql, sqlite)")

    model_config = ConfigDict(arbitrary_types_allowed=True)


class MACSSQLInput(BaseModel):
    """Input schema for MAC-SQL workflow."""

    question: str = Field(..., description="Natural language question", min_length=1)
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    session_id: Optional[str] = Field(default=None, description="Session ID for context")
    explain_mode: bool = Field(default=False, description="Return reasoning without executing")
    use_cache: bool = Field(default=True, description="Use cached results if available")
    timeout_seconds: float = Field(default=30.0, description="Query execution timeout", gt=0, le=300)
    max_rows: int = Field(default=10000, description="Maximum rows to return", gt=0, le=100000)


class MACSSQLOutput(BaseModel):
    """Output schema for MAC-SQL workflow."""

    # Generated SQL
    sql: str = Field(..., description="Generated SQL query")
    dialect: str = Field(default="postgres", description="SQL dialect")

    # Results (if executed)
    data: Optional[List[Dict[str, Any]]] = Field(default=None, description="Query results (if executed)")
    rows_returned: int = Field(default=0, description="Number of rows returned")

    # Reasoning (if explain_mode=True)
    schema_selection_reasoning: Optional[str] = Field(default=None, description="Selector agent reasoning")
    decomposition_reasoning: Optional[str] = Field(default=None, description="Decomposer agent reasoning")
    refinement_reasoning: Optional[str] = Field(default=None, description="Refiner agent reasoning")

    # Metadata
    execution_time_ms: float = Field(default=0.0, description="Total execution time")
    cached: bool = Field(default=False, description="Result from cache")
    complexity_score: float = Field(default=0.0, description="Query complexity score")

    # Validation
    is_valid: bool = Field(default=True, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors")

    # Error handling
    success: bool = Field(default=True, description="Overall success status")
    error_message: Optional[str] = Field(default=None, description="Error message if failed")
