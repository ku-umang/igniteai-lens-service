import operator
from enum import Enum
from typing import Annotated, Any, Dict, List, Optional
from uuid import UUID

from pydantic import BaseModel, ConfigDict, Field

from core.integrations.schema import DataSourceResponse


class QuestionType(str, Enum):
    """Classification types for user questions."""

    WHAT_IF = "what_if"  # Scenario analysis, "what if X changes?"
    TREND = "trend"  # Time-based patterns
    CORRELATION = "correlation"  # Relationships between variables
    FORECASTING = "forecasting"  # Predict future values
    COMPARISON = "comparison"  # Compare groups/segments
    SEGMENTATION = "segmentation"  # Group similar items
    ANOMALY_DETECTION = "anomaly_detection"  # Find outliers
    DESCRIPTIVE = "descriptive"  # Basic statistics/summary


class QueryStepStatus(str, Enum):
    """Status of a query step in the execution plan."""

    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"


class SchemaContext(BaseModel):
    """Schema context selected by the Selector agent."""

    tables: List[Dict[str, Any]] = Field(default_factory=list, description="Selected table metadata")
    columns: List[Dict[str, Any]] = Field(default_factory=list, description="Selected column metadata")
    relationships: List[Dict[str, Any]] = Field(default_factory=list, description="Table relationships (FKs)")
    example_queries: List[Dict[str, Any]] = Field(default_factory=list, description="Relevant example queries")
    reasoning: str = Field(default="", description="Selector agent reasoning")


class GeneratedSQL(BaseModel):
    """SQL generated by the Refiner agent."""

    sql: str = Field(default="", description="Generated SQL query")
    dialect: str = Field(default="postgres", description="SQL dialect")
    reasoning: str = Field(default="", description="Refiner agent reasoning")
    is_validated: bool = Field(default=False, description="SQL validation status")
    validation_errors: List[str] = Field(default_factory=list, description="Validation errors")


class ExecutionResult(BaseModel):
    """SQL execution result."""

    success: bool = Field(default=False, description="Execution success status")
    rows: List[Dict[str, Any]] = Field(default_factory=list, description="Rows returned")
    execution_time_ms: float = Field(default=0.0, description="Execution time in milliseconds")
    error_message: Optional[str] = Field(default=None, description="Error message (if failed)")
    truncated: bool = Field(default=False, description="Whether the result was truncated")
    rows_returned: int = Field(default=0, description="Number of rows returned")


class VisualizationSpec(BaseModel):
    """Visualization specification for Plotly charts."""

    chart_type: str = Field(..., description="Type of chart (line, bar, scatter, etc.)")
    plotly_spec: Dict[str, Any] = Field(..., description="Plotly JSON specification")
    title: str = Field(..., description="Chart title")
    description: Optional[str] = Field(default=None, description="Chart description")
    generation_method: str = Field(default="rule_based", description="Generation method (rule_based or llm)")
    generation_time_ms: float = Field(default=0.0, description="Time taken to generate visualization")


class ClassificationResult(BaseModel):
    """Question classification result from Classifier agent."""

    question_type: QuestionType = Field(default=QuestionType.DESCRIPTIVE, description="Classified question type")
    confidence: float = Field(default=1.0, description="Classification confidence score (0-1)", ge=0.0, le=1.0)
    reasoning: str = Field(default="", description="Classification reasoning")


class QueryStep(BaseModel):
    """Individual query step in an execution plan."""

    step_number: int = Field(..., description="Step number in the plan (1-indexed)")
    description: str = Field(..., description="Natural language description of this step")
    purpose: str = Field(..., description="Why this step is needed")
    depends_on: List[int] = Field(default_factory=list, description="Step numbers this depends on")
    status: QueryStepStatus = Field(default=QueryStepStatus.PENDING, description="Current status")

    # SQL-specific requirements
    required_tables: List[str] = Field(default_factory=list, description="Tables needed for this step")
    aggregations: List[str] = Field(default_factory=list, description="Aggregations needed")
    filters: List[str] = Field(default_factory=list, description="Filter conditions")


class ExecutionPlan(BaseModel):
    """Multi-step execution plan from Planner agent.

    Note: The plan is now used as structured reasoning context for generating a single SQL query.
    The steps represent the logical breakdown of the problem, but don't map to separate SQL executions.
    """

    steps: List[QueryStep] = Field(default_factory=list, description="Ordered list of query steps (used as reasoning context)")
    current_step_index: int = Field(default=0, description="[DEPRECATED] No longer used in single-SQL workflow")
    is_complete: bool = Field(default=False, description="[DEPRECATED] No longer used in single-SQL workflow")
    requires_iteration: bool = Field(default=False, description="Whether more steps may be added based on results")
    reasoning: str = Field(default="", description="Overall planning reasoning")
    strategy: str = Field(default="", description="High-level strategy for answering the question")


class AnalysisResult(BaseModel):
    """Analysis result synthesizing multiple query results."""

    insights: List[str] = Field(default_factory=list, description="Key insights from the analysis")
    answer: str = Field(..., description="Natural language answer to the original question")
    supporting_evidence: List[Dict[str, Any]] = Field(
        default_factory=list,
        description="Supporting data points and evidence",
    )
    confidence: float = Field(default=1.0, description="Confidence in the analysis (0-1)", ge=0.0, le=1.0)
    recommendations: List[str] = Field(default_factory=list, description="Actionable recommendations (if applicable)")
    limitations: List[str] = Field(default_factory=list, description="Known limitations or caveats")
    reasoning: str = Field(default="", description="Analysis reasoning")


class ChatMessage(BaseModel):
    """Simplified chat message for conversation history."""

    question: str = Field(..., description="User's question")
    sql: Optional[str] = Field(default=None, description="Generated SQL (if any)")


class AgentState(BaseModel):
    """State schema for Agent workflow using LangGraph.

    This state is passed between agents and tracks the complete workflow
    from question to SQL execution.
    """

    # Input
    user_question: str = Field(..., description="User's natural language question")
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    datasource: DataSourceResponse = Field(..., description="Datasource")
    session_id: Optional[str] = Field(default=None, description="Session ID for context/history")

    # Chat History & Optimization
    chat_history: List[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation history for context-aware optimization",
    )

    optimized_question: Optional[str] = Field(
        default=None,
        description="Context-aware optimized question (after optimizer agent)",
    )
    optimization_reasoning: Optional[str] = Field(
        default=None,
        description="Reasoning from question optimization",
    )

    # Question Classification (Classifier Agent)
    classification: Optional[ClassificationResult] = Field(default=None, description="Question classification result")

    # Schema Selection (Selector Agent) - may be populated multiple times for multi-query plans
    schema_context: Optional[SchemaContext] = Field(default=None, description="Selected schema context")

    # Query Planning
    execution_plan: Optional[ExecutionPlan] = Field(default=None, description="Multi-step execution plan")

    # SQL Generation (Refiner Agent) - Single SQL for entire question
    generated_sql: Optional[GeneratedSQL] = Field(
        default=None,
        description="Generated SQL query that answers the entire question (plan used as reasoning context)",
    )

    # Execution - Single result from executing the generated SQL
    execution_result: Optional[ExecutionResult] = Field(
        default=None,
        description="Execution result from running the generated SQL query",
    )

    # Analysis (Analysis Agent)
    analysis_result: Optional[AnalysisResult] = Field(
        default=None,
        description="Synthesized analysis of multiple query results",
    )

    # Visualization
    visualization_spec: Optional[VisualizationSpec] = Field(default=None, description="Visualization specification")

    # Control Flow
    current_step: str = Field(default="selector", description="Current workflow step")
    iteration_count: int = Field(default=0, description="Number of iterations (for retries)")
    max_iterations: int = Field(default=3, description="Maximum allowed iterations")

    # Error Tracking
    errors: Annotated[List[str], operator.add] = Field(default_factory=list, description="Accumulated errors during workflow")

    # Metadata
    retrieval_time_ms: float = Field(default=0.0, description="Schema retrieval time")
    total_time_ms: float = Field(default=0.0, description="Total workflow time")
    llm_calls: int = Field(default=0, description="Number of LLM calls made")

    # Configuration
    max_rows: int = Field(default=5000, description="Maximum rows to return")
    dialect: str = Field(default="postgres", description="SQL dialect from datasource (postgres, mysql, sqlite)")

    model_config = ConfigDict(arbitrary_types_allowed=True, extra="ignore")


class AgentInput(BaseModel):
    """Input schema for Agent workflow."""

    question: str = Field(..., description="Natural language question", min_length=1)
    datasource_id: UUID = Field(..., description="Target datasource identifier")
    tenant_id: UUID = Field(..., description="Tenant identifier")
    session_id: Optional[str] = Field(default=None, description="Session ID for context")
    chat_history: List[ChatMessage] = Field(
        default_factory=list,
        description="Recent conversation history for context-aware optimization",
    )
    max_rows: int = Field(default=5000, description="Maximum rows to return", gt=0, le=100000)


class AgentOutput(BaseModel):
    """Output schema for Agent workflow."""

    # Generated SQL (may be multiple for multi-query plans)
    sql: Optional[str] = Field(default=None, description="Generated SQL query")

    # Results (if executed)
    data: Optional[List[Dict[str, Any]]] = Field(default=None, description="Query results (if executed)")
    num_rows: int = Field(default=0, description="Number of rows returned")

    # Analysis (for multi-query workflows)
    analysis: Optional[Dict[str, Any]] = Field(default=None, description="Synthesized analysis result")
    insights: Optional[List[str]] = Field(default=None, description="Key insights from analysis")
    answer: Optional[str] = Field(default=None, description="Natural language answer to the question")

    # Visualization
    visualization_spec: Optional[Dict[str, Any]] = Field(default=None, description="Chart visualization specification")

    # Reasoning
    classification_reasoning: Optional[str] = Field(default=None, description="Classifier agent reasoning")
    schema_selection_reasoning: Optional[str] = Field(default=None, description="Selector agent reasoning")
    planning_reasoning: Optional[str] = Field(default=None, description="Planner agent reasoning")
    analysis_reasoning: Optional[str] = Field(default=None, description="Analysis agent reasoning")

    # Metadata
    total_time_ms: float = Field(default=0.0, description="Total workflow time")
    llm_calls: int = Field(default=0, description="Number of LLM calls made")

    # Error handling
    success: bool = Field(default=True, description="Overall success status")
    error_message: Optional[str] = Field(default=None, description="Error message if failed")
